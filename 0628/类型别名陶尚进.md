# 类型别名 (Type Alias)

老版本：type byte uint8
新版本：type byte = uint8

## 1、区分类型别名和类型定义
类型别名的写法：
`type TypeAlias = Type //TypeAlias只是Type的别名，本质上二者是同一类型`

```go
package main

import (
	"fmt"
)

//将NewInt定义为int类型
type NewInt int

//将int取别名叫IntAlias
type IntAlias = int

func main(){
	//将a声明为NewInt类型
	var a NewInt
	//查看a的类型名
	fmt.Printf("a type:%T\n",a)

	//将a2声明为IntAlias类型
	var a2 IntAlias
	//查看a2的类型名
	fmt.Printf("a2 type: %T\n",a2)
}
```

输出结果为：
```go
a type:main.NewInt
a2 type: int
```

## 2、非本地类型不能定义方法

## 3、在结构体成员嵌入时使用别名
    
```go
package main

import (
"fmt"
"reflect"
)

//定义商标结构
type Brand struct{
}

//为商标结构添加Show()方法
func (t Brand) Show(){
}

//为Brand定义一个别名FakeBrand
type FakeBrand = Brand

//定义车辆结构
type Vehicle struct {
	
//嵌入两个结构
FakeBrand
Brand
}

func main() {

  //声明变量a为车辆类型
  var a Vehicle

  //指定调用FakeBrand的Show
  a.FakeBrand.Show()

  //取a的类型反射对象
  ta := reflect.TypeOf(a)

  //遍历a的所有成员
  for i := 0;i < ta.NuFiled();i++ {

  //a的成员信息
  f := ta.Field(i)

  //打印成员的字段名和类型
  fmt.Printf("FieldName: %v,FieldType: %v\n",f.Name,f.Type
  Name())
   }
}
```

代码输出如下：
```go
FieldName:FakeBrand,FieldType:Brand
FieldName:Brand,Fieldtype:Brand
```

本例中，FakeBrand是Brand的一个别名。在Vehiclc中嵌入FakeBrand和Brand，并不意味这个嵌入两个Brand。FakeBrand的类型会以名字的方式保留在Vehicle的成员中。

   
