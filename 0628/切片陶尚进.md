# 切片：动态分配大小的连续空间

切片三要素：地址、大小、容量

## 1、从数组或切片生成新的切片：
从连续内存区域生成切片：slice [开始位置：结束位置]

从数组生成切片：
```go
var a = [3]int{1,2,3}
fmt.Println(a,a[1:2])
```
代码运行结果如下：
`[1 2 3] [2]`

* 取出的元素数量：结束位置-开始位置
* 取出元素不包含结束位置对应的索引
* 当缺少开始位置时，表示从连续区域开头到结束位置
* 当缺少结束位置时，表示从开始位置到连续位置结尾
* 二者同时缺少时，与切片本身等效
* 二者同时为0时，等效于空切片，一般用于切片复位


1.从指定范围生成切片

2.表示原有切片：a[:]

3.重置切片：a[0:0]

## 2、声明切片
`var name []T//name表示切片类型变量名,T表示切片的元素类型`

* 声明但未使用的切片的默认值是nil
`var strList []string`

* 已被分配内存的切片，即使没有元素，也不是nil了
`var numListEmpty = []int{} //本来可以在{}对切片进行初始化，但此处并未初始化，但是和nil比较时是false`

## 3、使用make()函数构造切片：动态创建切片
`make( []T,size,cap)`
T：切片的元素类型
size：就是为这个类型分配多少个元素
cap：预分配的元素数量，这个值设定后不影响size，只是可以提前分配空间，提高效率

```go
b := make([]int,2,10)
fmt.Println(len(b)
```
代码结果如下：
`2`

## 4、使用append()函数为切片添加元素
为切片动态添加元素,“扩容”操作往往发生在append()函数调用时。容量扩展规律按2倍数扩展。
  
```go
package main

import "fmt"

func main(){

	var numbers []int

	for i :=0;i < 10;i++{

		numbers = append(numbers,i)

		fmt.Printf("len: %d  cap: %d  pointer: %p  numbers: %d\n",len(numbers),cap(numbers),numbers,numbers)
	}
}
```

代码运行结果：
```go
len: 1  cap: 1  pointer: 0xc00000a0a8  numbers: [0]
len: 2  cap: 2  pointer: 0xc00000a100  numbers: [0 1]
len: 3  cap: 4  pointer: 0xc000010300  numbers: [0 1 2]
len: 4  cap: 4  pointer: 0xc000010300  numbers: [0 1 2 3]
len: 5  cap: 8  pointer: 0xc00000e300  numbers: [0 1 2 3 4]
len: 6  cap: 8  pointer: 0xc00000e300  numbers: [0 1 2 3 4 5]
len: 7  cap: 8  pointer: 0xc00000e300  numbers: [0 1 2 3 4 5 6]
len: 8  cap: 8  pointer: 0xc00000e300  numbers: [0 1 2 3 4 5 6 7]
len: 9  cap: 16  pointer: 0xc000102100  numbers: [0 1 2 3 4 5 6 7 8]
len: 10  cap: 16  pointer: 0xc000102100  numbers: [0 1 2 3 4 5 6 7 8 9] //len()并不等于cap
```

append()除了添加一个元素外，也可以一次添加多个元素


## 5、复制切片元素到另一个切片:copy()函数
格式：`copy( destSlice,srcSlice []T) int`
srcSlice为数据来源切片
dextSlice为复制的目标，目标切片必须分配过空间且足够承载复制的元素个数

```go
package main

import "fmt"

func main(){

	//设置元素数量为1000
	const elementCount = 1000

	//预分配足够多的元素切片
	srcData := make([]int,elementCount)

	//将切片赋值
	for i := 0;i < elementCount;i++{
		srcData[i] = i
	}

	//引用切片数据
	refData := srcData

	//预分配足够多的元素切片
	copyData :=make([]int,elementCount)
	//将数据复制到新的切片空间
	copy(copyData,srcData)

	//修改原始数据的第一个元素
	srcData[0] = 999

	//打印引用切片的第一个元素
	fmt.Println(refData[0])

	//打印复制切片的第一个和最后一个元素
	fmt.Println(copyData[0],copyData[elementCount-1])

	//复制原始数据从4到6
	copy(copyData,srcData[4:6])

	for i := 0;i < 5;i++{
		fmt.Printf("%d ",copyData[i])
	}
}
```
代码运行结果如下：
```go
999
0 999
4 5 2 3 4
```

## 6、从切片中删除元素

```go
package main

import "fmt"

func main(){

 seq := []string{"a","b","c","d","e"}

 //指定删除位置
 index := 2

 //查看删除位置之前和之后的元素
 fmt.Println(seq[:index],seq[index+1:])

 //将删除元素之前和之后的元素连接起来
 seq = append(seq[:index],seq[index+1:]...)
 fmt.Println(seq)
}
```

代码运行结果：
```go
[a b] [d e]
[a b d e]
```



