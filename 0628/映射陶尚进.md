# 映射（map）
当使用任意类型的关联时，就需要用到映射。Go语言提供的映射关系容器为map，map使用散列表（hash）实现。

## 添加关联到map并访问关联和数据
map定义
`map[KeyType]ValueType`
KeyType为键类型。
ValueType为键对应的值类型。
一个map里，符合KeyType和ValueType的映射总是成对出现。

```go
scene := make(map[string]int)//map是一个内部实现的类型，需要用make创建

scene["route"] = 66//加入映射，key可以使用除函数外的任何类型

fmt.Println(scene["route"])

v := scene["route2"]//route2是一个不存在的键，返回类型默认值
fmt.Println(v)
```
代码输出结果：
```go
66
0
```

某些情况下，需要明确知道查询中的某个键是否在map中存在，可使用以下写法：
`v,ok := scene["route"]`
在默认获取键值的基础上，多取了一个变量ok，可以判断route是否存在于map中。

map还有一种在声明时填充内容的方式，代码如下：
```go
m := map[string]strin{
    "W":"forward"
    "A":"left"
    "S":"backward"
    "D":"right"
}
```
例子中并没有使用make，而是在大括号内进行内容定义，冒号左边是key，右边是value，键值之间使用逗号分隔。
## 遍历map的“键值对”
map的遍历使用 for range循环完成，代码如下：
```go
scene := make(map[string]int)

scenen["route"] = 66
scene["brazil"] = 4
scene["china"] = 960

for k,v := range scene {
    fmt.Println(k,v)
}
```
如果只遍历值，代码如下：
```go
for _,v := range scene {
    fmt.Println(v)
}
```
如果只遍历键，代码如下：
```go
for k := range scene {
    fmt.Println(k)
}
```
值得注意的是，遍历输出元素的顺序和填充顺序无关。

如果需要特定顺序的遍历结果，可以做排序，代码如下：
```go
scene := make(map[string]int)

//准备map数据
scenen["route"] = 66
scene["brazil"] = 4
scene["china"] = 960

//声明一个切片保存map数据
var sceneList []string





